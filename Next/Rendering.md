# 1. 서버 컴포넌트 (Server Components)

## 서버 컴포넌트
리액트 서버 컴포넌트(RSC)를 사용하면 UI를 서버에서 렌더링하고 선택적으로 캐싱할 수 있습니다.
Next.js에서 렌더링 작업은 스트리밍과 부분 렌더링을 가능하게 하기 위해 경로 세그먼트별로 추가로 분할됩니다.
이를 위한 3가지 전략이 있습니다.

- 정적렌더링 (Static Rendering)
- 동적렌더링 (Dynamic Rendering)
- 스트리밍 (Streaming)

## 서버 컴포넌트의 이점

- 데이터 패칭
  - 서버 컴포넌트를 사용하면 데이터 패칭을 서버에서 수행하여, 작업자의 데이터 소스와 가까운 곳에서 처리할 수 있습니다.
  - 이러면 렌더링에 필요한 데이터를 패치해오는데 걸리는 시간을 줄이고
  - 클라이언트에서 필요한 요청수를 줄임으로써 성능이 향상됩니다.
- 보안
  - 서버컴포넌트는 민감데이터와 토큰과 API 키와 같은 서버에 있는 로직을 클라이언트에 노출할 위험없이 보호합니다.
- 캐싱
  - 서버에 렌더링하면서, 결과물은 캐싱되어 후속 요청과 여러 사용자에게 재사용 될 수 있습니다.
  - 이를 통해 성능을 개선하고, 각 요청마다 반복적으로 렌더링하거나 데이터를 가져오는 부담을 줄여 비용을 절감할 수 있습니다.
- 성능
  - 서버컴포넌트는 기본성능을 최적화 할 수 있는 추가적인 도구들을 제공합니다.
  - 예를들어, 너가 전체 클라이언트 컴포넌트로 구성된 앱을 시작할 때, 유저인터렉션이 없는 부분을 서버컴포넌트로 변경하면 클라이언트 사이드 자바스크립트 코드의 양이 줄어듭니다.
  - 이거는 작은 클라이언트사이드 자바스크립트를 다운받고 분석하고 실행하기 때문에 느린 인터 또는 저성능 디바이스 유저에게 유용하다. 
- 초기 페이지 로드 및 첫번 째 콘텐츠 페인트(First Content Paint, FCP)
  - 서버에서는, 페이지를 랜더하기 위해 핑료한 자바스크립트를 다운받고 분석하고 실행하는 것을 기다리지 않고,
  - 사용자들에게 즉시 페이지를 보여줄 수 있는 HTML을 생성할 수 있다.
  - (서버컴포넌트는 CSSOM+DOM 계산해서 렌더트리 만들지않고 (논인터렉션이니) 랜더트리 만들어진걸 가져온다는 뜻?)
- 검색 엔진 최적화 및 소셜 네트워크 공유성
  - 서버에서 렌더링된 HTML은 검색 엔진 봇이 페이지를 색인화하는 데 사용할 수 있으며,
  - 소셜 네트워크 봇이 페이지의 미리 보기(소셜 카드)를 생성하는 데 활용될 수 있습니다.
- 스트리밍
  - 서버컴포넌트는 청크단위로 렌더링 작업을 분리할 수 있습니다.
  - 그리고 청크들이 준비되는 대로 클라이언트에 스트리밍할 수 있도록 합니다.
  - 이를 통해 사용자는 전체 페이지가 서버에서 렌더링될 때까지 기다리지 않고 일부 콘텐츠를 더 빨리 확인할 수 있습니다.

## 서버컴포넌트를 Next.js에서 사용하기
디폴트로 넥스트는 서버 컴포넌트가 디폴트입니다.
이로써 추가적인 설정 없이 서버렌더링을 구현할 수 있습니다. 
그리고 클라이언트 컴포넌트는 필요하면 선택할 수 있습니다.

## 서버 컴포넌트는 어떻게 렌더링되는지?
서버에서, 넥스트는 렌더링을 조율하기 위해서 React Api를 사용합니다.(useEffect, useState같은것)
렌더링은 청크단위로 분리됩니다: 개별 라우트 새그먼트와 서스팬스 바운더리(<pages/> 영역을 감싸는 <Suspense fallback={} />)

각 청크는 두단계로 렌더됩니다.
- 첫번째: 리액트는 서버컴포넌트를 React Server Component Payload(RSC Payload) 라고 불리는 특별한 데이터 포멧으로 렌더링합니다.
- 두번째: 넥스트는 RSC Payload와 클라이언트 컴포넌트의 자바스크립트 명령(로직)을 사용하여 HTML을 서버에서 렌더링한다.
  - 이게 서버컴포넌트에서 사용자 인터렉션이 없으니까 RSC 페이로드를 보내서 클라이언트가 화면을 즉시 볼 수 있는것까지는 이해했는데,
  - Javascript 명령을 사용하여 서버에서 HTML을 렌더링한다는건 Javascript 코드를 어떻게 한다는건지?
  - -> 답안: 서버컴포넌트 렌더링에 자바스크립트가 여전히 중요한 역할을 함 (두가지 역할)
    - 첫번째는 RSC Payload로는 HTML을 못 만듬. 자바스크립트가 서버에서 돌아가야 만들 수 있음
    - 두번째는 서버컴포넌트 자식컴포넌트인 클라이언트 컴포넌트는 서버에서 완전히 렌더링 할 수 없기에 클라이언트쪽은 HTML안에 자바스크립트를 삽입함. e.g., Script 태그안에 하이드레이션을 위한 코드가 들어감

클라이언트에서는, 
- 서버에서 생성된 HTML을 즉시 표시하여 사용자가 빠르게 비상호작용(preview) 상태의 페이지를 볼 수 있도록 합니다. (이는 초기 페이지 로드에만 해당됩니다.)
  -  서버에서 RSC Payload를 생성, 사용자에게 즉시 HTML 표시 (자바스크립트가 서버에서 돌아가서 HTML로 만들어줌, 비상호작용 상태의 페이지임)
-  클라이언트에서 RSC Payload를 받아 트리를 동기화 & DOM 업데이트
  - 이제 Next.js는 서버에서 받은 RSC Payload를 사용하여, 기존의 클라이언트 측 React 트리와 비교(diffs) 함.
  - 변경된 부분(서버에서 렌더링된 UI)이 있다면, 이를 React의 reconciliation(조정) 과정을 통해 DOM에 반영함
  - = 서버 렌더트리와 클라이언트 렌더트리를 맞추는 과정
- Client Components 하이드레이션 진행
  - 이제 Next.js는 Client Components를 하이드레이션해서 인터랙티브하게 만듦. (이 때 비상호작용 컴포넌트 -> 사용자가 버튼누를 수 있는 상호작용 컴포넌트가됨)
  - React는 서버에서 미리 렌더링된 UI를 유지하면서, 클라이언트에서 필요한 JavaScript를 실행하여 동작하게 함.


## 서버 컴포넌트 전략

### 정적렌더링 (Static Rendering) (default)

### 동적렌더링 (Dynamic Rendering)
#### 동적 렌더링으로 전환

### 동적 APIs

### 스트리밍


# 2. 클라이언트 컴포넌트 (Client Components)

# 3. 컴포지트 패턴 (Composition Patterns)
- 객체들의 관계를 트리 구조로 구성하여 부분과 전체를 나타내는 패턴


# 4. 부분 사전렌더링 (Partial Prerendering)

# 5. 런타임 (Runtimes)
