# 실행 컨택스트 (This!!!)
~~~
자바스크립트는 콜스택에 실행할 함수들을 모아 문맥(context)을 만든다.
실행 컨택스트는 콜스택 최상단의 실행할 코드에 제공할 환경 정보들을 모아놓은 '객체'이다.
(지금 내가 사용할 수 있는 변수들, 함수들 모음집이라고 생각)

실행 컨택스트에 담기는 정보
1. Variable Environment(변수 환경): 변수명과 현수 현재 값, 함수 명과 참조가 저장됨
2. Lexical Environment(어휘 환경): 변수, 함수 외에도 외부 스코프와 연결정보를 가짐 -> 이 정보는 스코프체인 형성에 사용됨
   -> Lexical Environment는 스코프체인과 함께 클로저를 구현하는데 사용됨
3. ThisBinding (this): 현재 실행 컨택스트에서 This 키워드가 바라봐야 할 대상 객체
~~~

# 실행 컨택스트가 하는 일(요약)
~~~
1. 선언된 변수와 함수를 스코프의 맨위로 끌어 올린다.
2. 외부 환경 정보 구성
3. this 값을 설정한다.
~~~

# 클로저
~~~
클로저는 함수가 정의될 때 Lexical Environment(어휘 환경)을 기억(스냅샷)해서 함수 내부에서 외부 변수에 접근할 수 있는 기능을 의미함.
1. 함수 안에 다른 함수가 있을 때, 내부 함수는 외부 함수의 변수에 접근할 수 있다.
2. 외부 함수가 종료된 이후에도 내부 함수는 외부 함수의 변수에 접근할 수 있다.
3. private 변수처럼 사용 가능

ex 1)
function outer() {
  let x = 10;

  // inner 함수가 선언되면서 외부함수에 대한 스코프체인을 보고 x 값을 가져다 사용
  function inner() {
    console.log(x);
  }

  return inner;
}

const closureFunction = outer(); // inner() 리턴함;
closureFunction(); // console.log(10);

ex 2)
// 클로저 함수 =
const createCounter = () => {
  let count = 0; // 비공개 변수

  // 리턴하면서 함수를 반환하는데 이 함수가 선언될 때 외부함수에 대한 스코프체인을 보고 count 값 가져다 씀 
  return () => {
    return ++count;
  }
}

const counter1 = createCounter();
console.log(counter1()); // 1
console.log(counter1()); // 2 

const counter2 = createCounter();
console.log(counter2()); // 1 (독립적인 상태를 유지)
console.log(counter1()); // 3 (counter1과 counter2는 서로 다른 클로저를 가짐)

~~~

# 내가 마주쳤던 클로저 예제
~~~
스크롤 애니메이션으로 300px 정도 올라왔을 때 스타일을 추가하여 화면에 보여줄 수 있도록 작업했는데
let 변수로 선언해놓고 정확하게 원하는 타이밍에 애니메이션이 잘 동작하여 넘어갔는데, 코드리뷰 때 눈에 확 들어왔다.
단순 정보성 페이지라 문제될 일은 없었지만, 복잡한 기능을 하는 페이지였다면 문제가 생겼을 것이다..ㅠㅠ

// 현재 섹션
const section = useRef(-1);

// 위치 값을 저장해놔요
const targetElementsRef = useRef([]);

useEffect(() => {
   const arrElements = document.getElementsByClassName("mileage-animation-section");

   // 맨 처음에 이렇게 썼다. 
   // let position = new Array(); // 여기가 이슈다....

   Array.prototype.map.call(arrElements, (e) => {
      targetElementsRef.current.push(e.getBoundingClientRect().top + 300 || 0)

      // 이렇게 써도 함수가 (e)=> {...} 함수가 생성될 때 외부함수에 대한 스코프체인을 보고
      // position 변수에 접근할 수 있었는데 별 문제 없어보일지라도, 의도하지 않은 코드기때문에 ref로 변경하였다..
      // position.push(e.getBoundingClientRect().top + 300 || 0);
   })

   window.addEventListener("scroll", calcPosition), {
     passive: true // 스크롤 이벤트를 더 부드럽게 처리하고 렌더링을 최적화하기 위해 사용
   }); 
   window.addEventListener("resize", calcPosition), {
     passive: true
   });
   window.addEventListener("beforeunload", initPosition);

   ()  => {
     window.removeEventListener("scroll", calcPosition);
     window.removeEventListener("resize", calcPosition);
     window.removeEventListener("beforeunload", initPosition);
     d.current = {
         section: 0
     }
   }
}, []);

   /**
      * 현재 섹션 비교하여 숨겨둔 섹션을 보여줘요
   */
   const calcPosition = () => {
      const e = section.current;
      const i  = window.scrollY;

      if ( targetElementsRef.current.length > e + 1 &&
            targetElementsRef.current[e + 1] <= window.innerHeight + i ) {
         r(e + 1);
         section.current += 1;
         j && j.setAttribute("data-scroll-header", 0 === i ? "false" : "true");
      }
   }

   /**
      * 위치 초기화
   */
   const initPosition = () => {
      window.scrollTo(0, 0);
   }
   ~~~

## this 퀴즈
~~~javascript
var myObject = {
   name: "gayoung",
   showName: function () {
      console.log(this);
   ]
} 

var saveFunc = myObject.showName;

var anotherObject = {
   name: "kong",
   showName: myObject.showName
}

myObject.showName(); // this는 상위스코프인 myObject 객체가됨

saveFunc(); // myObject.showNam를 참조하지만 실제로 window를 가리킴

anotherObject.showName(); // anotherObject의 상위스코프인 anotherObject 객체를 가리킴
~~~
